<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人应用</title>
    <url>/2024/02/04/personal-assistant-app/</url>
    <content><![CDATA[<h1 id="一、课题理解与分析："><a href="#一、课题理解与分析：" class="headerlink" title="一、课题理解与分析："></a>一、课题理解与分析：</h1><p><img src="/2024/02/04/personal-assistant-app/20240204154558.png" alt="Bshu"><br><strong>所有记分点要求内容均已实现。</strong></p>
<p>根据要求来看，主界面主要实现的是向各个界面的跳转功能。备忘录界面实现的记录的存储、显示以及其他查看操作。待办事项界面可以通过借鉴备忘录界面实现一些记录的存储、显示以及其他查看操作，但是多了时间和提醒的概念。记账只要结合备忘录界面和待办事项界面即可。</p>
<p>对于数据的存储，可以采用数据库来进行存储以及处理。对于大部分的需求内容，都可以采用课上的讲义内容来执行，例如第二章的界面跳转、第三章的recycleview、fab、menu等、第五章的通知提醒等。<br>文件链接在文末<br> <span id="more"></span></p>
<h1 id="二、项目结构"><a href="#二、项目结构" class="headerlink" title="二、项目结构"></a>二、项目结构</h1><p>├── src </p>
<p>│ ├── main</p>
<p>│ │ ├── java/com/example/personalassistant </p>
<p>│ │ │ ├── MainActivity.java //实现界面设计</p>
<p>│ │ │ ├── MemoActivity.java </p>
<p>│ │ │ ├── TodoActivity.java </p>
<p>│ │ │ ├── ExpenseActivity.java</p>
<p>│ │ │ ├── SettingsActivity.java</p>
<p>│ │ │ ├── MemoAdapter.java //适配器，实现与recycleview的绑定</p>
<p>│ │ │ ├── TodoAdapter.java </p>
<p>│ │ │ ├── ExpenseAdapter.java </p>
<p>│ │ │ ├── Memo.java //实现基本类的设计</p>
<p>│ │ │ ├── Todo.java </p>
<p>│ │ │ ├── Expense.java </p>
<p>│ │ │ ├── MemoDatabaseHelper.java //数据库相关，实现数据存储以及处理</p>
<p>│ │ │ ├── TodoDatabaseHelper.java </p>
<p>│ │ │ ├── ExpenseDatabaseHelper.java </p>
<p>│ │ │ ├── AlarmReceiver.java //实现接收广播并发送通知</p>
<p>│ │ │ ├── DateTimeUtils.java//实现时间戳与标准时间格式的转化</p>
<p>│ │ │ ├── TimeRange.java //enum类，存取TODAY,MONTH,YEAR三个宏</p>
<p>│ │ ├── res </p>
<p>│ │ │ ├── layout </p>
<p>│ │ │ │ │ ├── activity_main.xml //界面布局设计</p>
<p>│ │ │ │ │ ├── activity_memo.xml </p>
<p>│ │ │ │ │ ├── activity_todo.xml </p>
<p>│ │ │ │ │ ├── activity_expense.xml </p>
<p>│ │ │ │ │ ├── activity_settings.xml </p>
<p>│ │ │ │ │ ├── memo_list_item.xml //recycleview面板上每个item的内容显示设计</p>
<p>│ │ │ │ │ ├── todo_list_item.xml </p>
<p>│ │ │ │ │ ├── expense_list_item.xml </p>
<p>│ │ │ │ │ ├── popup_edit_expense.xml //实现添加、修改、删除的popupwindow界面设计</p>
<p>│ │ │ │ │ ├── popup_edit_memo.xml</p>
<p>│ │ │ │ │ ├── popup_edit_todo.xml</p>
<p>│ │ │ │ ├── menu </p>
<p>│ │ │ │ │ ├── menu_main.xml //menu菜单设计</p>
<p>│ │ │ │ │ ├── menu_memo.xml </p>
<p>│ │ │ │ │ ├── menu_todo.xml </p>
<p>│ │ │ │ │ ├── menu_expense.xml </p>
<p>│ │ │ │ ├── drawable </p>
<p>│ │ │ │ │ ├── oip.jpg </p>
<p>│ │ │ │ │ ├── raa.jpg </p>
<p>│ │ │ │ │ ├── ic_add </p>
<p>│ │ │ │ │ ├── ic_save </p>
<p>│ │ │ │ │ ├── ic_notification</p>
<p>│ │ │ │ ├── values </p>
<p>│ │ │ │ │ ├── strings.xml</p>
<p>│ │ │ │ │ ├── arrays.xml</p>
<p>│ │ │ │ ├── xml</p>
<p>│ │ │ │ │ ├── preferences.xml//设置界面设计</p>
<h1 id="三、内容介绍与遇到的问题等"><a href="#三、内容介绍与遇到的问题等" class="headerlink" title="三、内容介绍与遇到的问题等"></a>三、内容介绍与遇到的问题等</h1><h2 id="1、主屏幕（实现了记分点1的所有内容）"><a href="#1、主屏幕（实现了记分点1的所有内容）" class="headerlink" title="1、主屏幕（实现了记分点1的所有内容）"></a>1、主屏幕（实现了记分点1的所有内容）</h2><h3 id="（1）设计思路"><a href="#（1）设计思路" class="headerlink" title="（1）设计思路"></a>（1）设计思路</h3><p>主要设计思路借鉴了第一次实验的实验内容，显示功能列表，实现设置屏幕。</p>
<p>记分点1：显示功能清单，备忘录、待办事项、记账，点击后进入相应的功能页面。应用栏显示设置菜单。进入设置页面后，可以对各功能的分类等信息进行设置。</p>
<p>主界面相关代码内容：</p>
<p><img src="/2024/02/04/personal-assistant-app/wps2.jpg" alt="Bshu"> </p>
<p>设置界面设计内容：</p>
<p><img src="/2024/02/04/personal-assistant-app/wps3.jpg" alt="Bshu"> </p>
<h3 id="（2）实验结果"><a href="#（2）实验结果" class="headerlink" title="（2）实验结果"></a>（2）实验结果</h3><p>实现功能清单的显示以及设置界面屏幕</p>
<p><img src="/2024/02/04/personal-assistant-app/wps4.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps5.jpg" alt="Bshu"> </p>
<h3 id="（3）操作步骤"><a href="#（3）操作步骤" class="headerlink" title="（3）操作步骤"></a>（3）操作步骤</h3><p>用户可以可以直接按下对应界面的按钮直接进入该界面，用户可以通过主界面右上角菜单中的设置选项、或者主界面的设置按钮进入设置界面</p>
<h3 id="（4）遇到的问题"><a href="#（4）遇到的问题" class="headerlink" title="（4）遇到的问题"></a>（4）遇到的问题</h3><p>问题：设置界面的显示存在问题。</p>
<p>分析：通过最后一堂课了解到用preferences来进行界面设计。</p>
<p>解决方案：用preference.xml来进行界面设计。</p>
<h2 id="2、备忘录（实现了记分点2、3、4所有内容）"><a href="#2、备忘录（实现了记分点2、3、4所有内容）" class="headerlink" title="2、备忘录（实现了记分点2、3、4所有内容）"></a>2、备忘录（实现了记分点2、3、4所有内容）</h2><h3 id="（1）设计思路："><a href="#（1）设计思路：" class="headerlink" title="（1）设计思路："></a>（1）设计思路：</h3><p>主要设计思路借鉴了最后一次的实验内容，即通过fab向Recycleview控件中添加内容。分类功能默认实现，即进入界面后已经进行了分类，具有相同的标签的记录将相邻排列，并只显示该类第一条记录的标签。</p>
<p>计分点2：显示备忘列表。可按创建时间、标题等对列表排序。</p>
<p>在设计备忘录界面时，我选择使用RecyclerView来展示备忘录列表，并使用Toolbar搭配Menu菜单为用户提供了按创建时间和标题排序的功能。通过在 MemoActivity.java 中实现了排序的方法，用户可以方便地选择不同的排序方式。这样，用户可以根据自己的需求，轻松查看备忘录列表。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps6.jpg" alt="Bshu"> </p>
<p>计分点3：支持添加、删除、修改备忘。</p>
<p>我确保用户能够方便地进行备忘录的添加、删除和修改操作。通过弹出 PopupWindow，用户可以轻松输入或编辑备忘录的标题、内容和标签。保存时，我在 saveOrUpdateMemo 方法中判断备忘录是否为空，从而进行添加或更新的操作，并及时更新备忘录列表。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps7.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps8.jpg" alt="Bshu"> </p>
<p>计分点4：支持分类和标签。支持按分类或标签筛选备忘。</p>
<p>我在备忘录中新增了标签属性，并提供了按标签筛选备忘录的功能。通过在 MemoDatabaseHelper.java 中提供了获取所有标签和按标签筛选备忘录的方法。在 MemoActivity.java 中实现了显示对话框的方法，并通过选择标签来更新备忘录列表来进行筛选。</p>
<p>备忘录默认实现分类，对于具有相同标签的记录，将会相邻排列，并只显示该类的第一条记录的标签值。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps9.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps10.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps11.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps12.jpg" alt="Bshu"> </p>
<h3 id="（2）实现结果："><a href="#（2）实现结果：" class="headerlink" title="（2）实现结果："></a>（2）实现结果：</h3><p>①按下浮动按钮后，将会弹出一个窗口，用户可以在此弹出窗口输入标题、内容、标签，输入完毕后可以按下保存按钮进行保存，也可以通过按下返回按钮取消添加。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps13.jpg" alt="Bshu"> </p>
<p>②在已有的备忘录记录当中，用户可以点击其中一条记录，来对该记录进行修改或者删除该记录。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps14.jpg" alt="Bshu"> </p>
<p>③用户也可以通过按下筛选按钮，根据标签内容进行筛选，也可以通过按下清除筛选部分来取消筛选</p>
<p><img src="/2024/02/04/personal-assistant-app/wps15.jpg" alt="Bshu"> </p>
<p>④用户可以在menu栏实现跳转设置界面、清空备忘录、排序等操作。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps16.jpg" alt="Bshu"> </p>
<p>⑤退出应用重新打开后，之前的备忘录记录依旧能够保留。</p>
<h3 id="（3）操作步骤："><a href="#（3）操作步骤：" class="headerlink" title="（3）操作步骤："></a>（3）操作步骤：</h3><p>用户打开备忘录界面后，可以按通过按下右下角的浮动按钮来添加记录，此时会显示一个popup窗口，你可以在该窗口输入相关信息并进行保存记录，此时删除按钮与返回按钮都表示取消保存记录。</p>
<p>保存记录后该记录会显示在Recycleview当中，点击对应记录，你可以对该记录进行修改/删除/取消修改操作。</p>
<p>按下筛选按钮，你可以根据具体的标签进行筛选。</p>
<p>打开右上角的菜单栏，你可以选择清除记录/设置/按创建日期排序/按标题排序/按标签分类（该分类默认实现）。</p>
<p>最后，用户可以按左上角的箭头返回至主界面。</p>
<h3 id="（4）遇到的问题："><a href="#（4）遇到的问题：" class="headerlink" title="（4）遇到的问题："></a>（4）遇到的问题：</h3><p>①问题:日志结果表面数据库表 “memo” 中缺少 “tags” 列但是代码中已经添加了“tags”列。</p>
<p>分析：由于在之前创建数据库时还没有开始做标签功能，导致数据库中缺少“tags”列，之后代码中添加了“tags”列但没有更新数据库，所以出现该问题。</p>
<p>解决方案：由于数据库已经创建，我们需要处理数据库升级的情况。</p>
<p>②问题：点击浮动按钮后，popupwindows只会闪动一下，并不会一直停留在屏幕上直到按下某个按钮。</p>
<p>分析：按照原先代码的逻辑，将只在函数代码执行过后popup窗口就会消失，需要将该窗口的显示与消失定义在某个事件当中。</p>
<p>解决方案：将 PopupWindow 的显示和隐藏放在按钮的点击事件中，并使用全局变量或其他方式来保存 PopupWindow 的实例</p>
<p>③问题：按下Toolbar控件左边的返回箭头没有反应，无法退回至主界面</p>
<p>分析：错误地将跳转至主界面事件放至menu的某个Item中</p>
<p>解决方案：使用 toolbar.setNavigationOnClickListener 为返回箭头按钮设置了点击事件，点击时执行 goToMainActivity() 方法，实现了跳转至主界面的功能。</p>
<h2 id="3、待办事项（实现了记分点5，6，7的所有内容）"><a href="#3、待办事项（实现了记分点5，6，7的所有内容）" class="headerlink" title="3、待办事项（实现了记分点5，6，7的所有内容）"></a>3、待办事项（实现了记分点5，6，7的所有内容）</h2><h3 id="（1）设计思路-1"><a href="#（1）设计思路-1" class="headerlink" title="（1）设计思路"></a>（1）设计思路</h3><p>大部分显示以及布局内容都是模仿备忘录界面实现，对于提醒部分，参考讲义第五章中的内容进行实现</p>
<p>计分点5：显示待办清单。支持按类别、日期筛选。</p>
<p>对于按种类筛选，将获取当前所有的种类内容，用户可以选择对应的种类</p>
<p>对于按日期筛选，根据选择的日期，设置起始时间戳为该日期00：00：00，截止日期为第二天的00：00：00，筛选时间戳在此范围内的记录</p>
<p><img src="/2024/02/04/personal-assistant-app/wps17.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps18.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps19.jpg" alt="Bshu"> </p>
<p>计分点6：添加、删除、修改待办事项。</p>
<p>此处与备忘录的增删改部分相近，但是待办事项界面设计日期与时间，所以增加了TimePicker与datePickerDialog来输入时间与日期</p>
<p><img src="/2024/02/04/personal-assistant-app/wps20.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps21.jpg" alt="Bshu"> </p>
<p>计分点7：支持提醒功能。提醒分单次和重复两种类型。</p>
<p>此处sendNotification函数包括了讲义中的createNotification函数与handleNotification函数。</p>
<p>由于使用重复提醒的函数为setInexactRepeating函数，所以重复提醒的第一次提醒时间会存在一定的延迟</p>
<p><img src="/2024/02/04/personal-assistant-app/wps22.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps23.jpg" alt="Bshu"> </p>
<h3 id="（2）实验结果-1"><a href="#（2）实验结果-1" class="headerlink" title="（2）实验结果"></a>（2）实验结果</h3><p>①界面整体布局，菜单内容</p>
<p><img src="/2024/02/04/personal-assistant-app/wps24.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps25.jpg" alt="Bshu"> </p>
<p>②筛选实现部分</p>
<p><img src="/2024/02/04/personal-assistant-app/wps26.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps27.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps28.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps29.jpg" alt="Bshu">（选择12.25筛选后）</p>
<p>③实现增删改部分，popup窗口内容，可以按下选择日期按钮显示日历，可以按下左下角的小键盘将钟表切换成直接输入时间。重复时间通过spinner来选择</p>
<p><img src="/2024/02/04/personal-assistant-app/wps30.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps31.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps32.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps33.jpg" alt="Bshu"> </p>
<p>④提醒部分，显然可以上方有通知提醒，下方有toast显示，重复提醒第一次的提醒时间可能要延迟3-5min</p>
<p><img src="/2024/02/04/personal-assistant-app/wps34.jpg" alt="Bshu"> </p>
<h3 id="（3）操作步骤-1"><a href="#（3）操作步骤-1" class="headerlink" title="（3）操作步骤"></a>（3）操作步骤</h3><p>用户进入到待办事项界面后，用户可以按下右下角的“+”浮动按钮来添加待办事项记录，用户可以依次1、输入标题、种类、描述，然后可以点击“选择日期”按钮，2、在弹出的日历中选择日期（默认为当天），3、然后用户可以直接在钟表上选择具体时间，或者在左下角的键盘来输入具体的时间。4、然后用户可以选择是否进行重复提醒，并在spinner中选择重复提醒的间隔时间。</p>
<p>同备忘录，用户可以直接点击某条记录来进行修改记录相关内容。</p>
<p>用户可以按下toolbar中的筛选选项来进行标签筛选以及日期筛选，按下标签筛选后，用户可以选择某个标签进行筛选；按下日期筛选后，用户也可以选择某个日期来筛选出记录中年月日与该日期相同的项。两种筛选都可以清除筛选。</p>
<p>用户可以通过右上角的菜单栏来进行清除所有待办事项记录/设置。</p>
<p>用户会在每条记录设置的时间收到通知提醒，但如果是重复提醒，第一次提醒的时间会延迟3-5分钟，但是之后的间隔时间基本准时。</p>
<p>最后，用户可以按左上角的箭头返回至主界面。</p>
<h3 id="（4）遇到的问题-1"><a href="#（4）遇到的问题-1" class="headerlink" title="（4）遇到的问题"></a>（4）遇到的问题</h3><p>①问题：有没有什么方式可以使用户对于时间的输入更方便，以替代文字输入</p>
<p>分析：如果存在日历以及钟表式的输入，可能更加直观与方便</p>
<p>解决方案：对于日期选择，可以用DatePickerDialog，对于时间选择，可以用TimePicker控件。</p>
<p>②问题：对于种类筛选能够正常执行，但是对于日期筛选无法执行。</p>
<p>分析：通过日志，沿着操作步骤逐步排查问题，最后发现筛选列表加入的条件为符合种类筛选条件且不符合日期筛选条件</p>
<p>解决方案：考虑到对于每种筛选方式，都要求另一种筛选方式不符合才行，可以对两种筛选方式的判断进行异或，实现只有两者的值不同时才可以进行筛选。（实际代码中对于两种情况直接进行罗列并用||连接）</p>
<p>③问题：再增加提醒功能与重复提醒功能后，运行程序，应用一直闪退</p>
<p>分析：通过日志的报错进行分析，找到错误对应的那一行，最后发现又是数据库生成的表（增加提醒功能前的表）不存在一些列。参考备忘录的方式，通过数据库升级来增加列，但是由于一些粗心错误，将一些变量加入到两个原来就存在的列中间，同时存在部分需要删除的变量，导致不能直接对尾部添加或单纯尾部添加并不能解决问题。</p>
<p>解决方案：理论上可以直接查找表的结构，然后进行DROP部分变量，再增加部分变量即可。最后直接修改数据库名，直接新建了一个数据库的表。</p>
<p>④问题：提醒功能始终无法实现。（实际解决过程中共发现三个问题）</p>
<p>分析：根据日志进行问题排查，发现广播能够正常发送，但是AlarmReceiver始终无法正常接收广播。对于整个代码走了一遍发现是否提醒与是否添加重复提醒变量之间存在混淆。修改后还是无法正常接收提醒，经过相关文档查询，发现setRepeating函数具有一定的延时性，在经过几分钟的等待后，发现广播能够正常被接收（日志显示了接收报告），但是手机屏幕上并没有生成通知弹窗。经过一天的研究，最终发现问题在于虚拟手机上关掉了该软件的通知权限。</p>
<p>解决方案：1、将是否提醒与是否添加重复提醒变量有关的函数进行调整，修改相关函数的参数名称以提高程序可读性。2、对于单次提醒采用setExactAndAllowWhileIdle实现准时提醒，但是重复提醒无法做到准时3、记得打开虚拟手机上的应用通知权限</p>
<h2 id="4、记账（实现了记分点8，9的所有内容）"><a href="#4、记账（实现了记分点8，9的所有内容）" class="headerlink" title="4、记账（实现了记分点8，9的所有内容）"></a>4、记账（实现了记分点8，9的所有内容）</h2><h3 id="（1）设计思路-2"><a href="#（1）设计思路-2" class="headerlink" title="（1）设计思路"></a>（1）设计思路</h3><p>结合备忘录的相关界面设计以及待办事项界面对于日期的相关处理进行设计。</p>
<p>计分点8：显示支出清单。默认显示当天、当月、当年的汇总值。可按日期、月份、年份、类别筛选支出清单，并显示筛选后的汇总值。</p>
<p>Timerange为所选的当天/当月/当年，按下筛选按钮后，系统可以切换至对应的日期，查询该日期当天/当月/当年的相关信息。</p>
<p><img src="/2024/02/04/personal-assistant-app/wps35.jpg" alt="Bshu"> </p>
<p><img src="/2024/02/04/personal-assistant-app/wps36.jpg" alt="Bshu"> </p>
<p>计分点9：添加、删除、修改支出项。</p>
<p>此处基本与备忘录界面的设计相同，多一个存储当前账单记录的记录日期的变量</p>
<p><img src="/2024/02/04/personal-assistant-app/wps37.jpg" alt="Bshu"> </p>
<h3 id="（2）实验结果-2"><a href="#（2）实验结果-2" class="headerlink" title="（2）实验结果"></a>（2）实验结果</h3><p>①实现记账主界面的设计，当天/当月/当年的选择</p>
<p><img src="/2024/02/04/personal-assistant-app/wps38.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps39.jpg" alt="Bshu"> </p>
<p>②实现筛选进行切换至其他日期</p>
<p><img src="/2024/02/04/personal-assistant-app/wps40.jpg" alt="Bshu"><img src="/2024/02/04/personal-assistant-app/wps41.jpg" alt="Bshu"> </p>
<p>③实现增删改的popup界面，如果输入不完整会显示相关toast内容</p>
<pre><code>![Bshu](personal-assistant-app/wps42.jpg)![Bshu](personal-assistant-app/wps43.jpg)
</code></pre><h3 id="（3）操作步骤-2"><a href="#（3）操作步骤-2" class="headerlink" title="（3）操作步骤"></a>（3）操作步骤</h3><p>用户打开备忘录界面后，可以按通过按下右下角的浮动按钮来添加记录，此时会显示一个popup窗口，你可以在该窗口输入相关信息并进行保存记录，此时删除按钮与返回按钮都表示取消保存记录。</p>
<p>用户可以通过选择spinner中的某一项来显示当天/当月/当年的相关账单以及总金额。</p>
<p>用户可以通过按下筛选按钮，来切换至某一天，来查看该日期下当天/当月/当年的相关账单以及总金额。</p>
<p>用户可以通过右上角的菜单栏来进行清除所有记账记录/设置。</p>
<p>最后，用户可以按左上角的箭头返回至主界面。</p>
<h3 id="（4）遇到的问题-2"><a href="#（4）遇到的问题-2" class="headerlink" title="（4）遇到的问题"></a>（4）遇到的问题</h3><p>①问题：用户如果在当前日期选择当月的信息的话，再进行筛选至某一天后，虽然显示的是该日的相关信息，但是spinner还是显示“当月”。</p>
<p>分析：timeRangeSpinner.setSelection();函数可以直接设置spinner的状态</p>
<p>解决方案：在updateExpenseListAndTotalAmount函数最后加入timeRangeSpinner.setSelection(0);代码即可。</p>
<h1 id="四、心得"><a href="#四、心得" class="headerlink" title="四、心得"></a>四、心得</h1><p>该次个人应用的设计是我遇到的工程量最大的开发内容。代码量之大，知识点之多，思维量之大不得不让我沉下心去做。整个项目内容做做停停大概花了小半个月来实现全部要求，是我感慨颇深。一方面使我增加了项目经历，增强了我的码力，对于应用开发有了更多的理解；另一方面也极大地改变了我作为ACM-ICPC算法竞赛校队成员的刁钻码风，为了实现大项目而被迫提高程序可读性。</p>
<p>项目中各界面的难度大概如下：主界面＜设置界面＜＜记账界面＜备忘录界面＜＜待办事项界面。主界面与设置界面主要就是外观，跳转等基础功能的设计。设置界面还好老师最后一堂课提了手能够有所了解。由于我是按照要求顺序所作，导致记账界面被放在了最后。对于做一整个界面首先是要有一个整体的设计与方案选择，由于我做的第一个界面是备忘录界面，这里以备忘录界面作为介绍。一开始，我根据之前所作的实验就决定采用fab按钮搭配recycleview来实现基本框架，在实现输入内容的时候，想起windows应用实践课程中使用的popupwindow，所以选择通过弹窗的形式来实现输入，这样既节省了空间，又可以保留背景避免过于单一。然后再根据最后一次实验实现menu时所使用的toolbar，整个界面框架到此就搭建完备了。</p>
<p>界面设计完毕后，就是对于具体要求的逻辑实践了。由于码力问题，每次写完一部分代码都能保证正确，在我的代码中也可以看到很多通过日志来进行debug的痕迹。但是有时候也会存在一些代码怎么看都对结果就是不能正常实现目标的情况，究其原因都是一些偏门错误，例如缺少依赖、数据库没有升级、应用通知权限关闭等情况。这些问题的出现为我造成了巨大的麻烦，经过相关资料查询，以及一些细节的检查才进行解决。尤其是待办事项的筛选以及提醒部分，两个部分分别消耗我两天时间，前者是因为代码写的太差了导致逻辑较为麻烦，后者主要就是没想到虚拟手机关闭了应用的通知权限。但这些错误也是给了我未来的开发许多经验，例如备忘录的数据库升级问题，我在待办事项遇到时便有了相应的解决方案。虽然过程痛苦，而且应用可能还存在某些bug，但是整个结果下来还是收获颇丰。</p>
<h1 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h1><p>magnet:?xt=urn:btih:0940D627735E0F32B1DA1CC58F2E4C6979AEC263&amp;dn=personalassistant.rar</p>
]]></content>
      <categories>
        <category>移动应用基础</category>
      </categories>
      <tags>
        <tag>移动应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一个博客</title>
    <url>/2024/01/31/hello/</url>
    <content><![CDATA[<h3 id="这是我的第一个博客，我将在这里分享我的相关内容"><a href="#这是我的第一个博客，我将在这里分享我的相关内容" class="headerlink" title="这是我的第一个博客，我将在这里分享我的相关内容"></a>这是我的第一个博客，我将在这里分享我的相关内容</h3>]]></content>
  </entry>
  <entry>
    <title>线段树的一些trick</title>
    <url>/2024/02/03/segment-tree-trick/</url>
    <content><![CDATA[<p>以下是我根据洛谷limit的线段树题单中挑了一部分有趣的题来做，一些trick还是比较有意思的。<br> <span id="more"></span></p>
<h2 id="XOR-on-Segment"><a href="#XOR-on-Segment" class="headerlink" title="XOR on Segment"></a>XOR on Segment</h2><p><a href="https://www.luogu.com.cn/problem/CF242E">https://www.luogu.com.cn/problem/CF242E</a></p>
<p><img src="/2024/02/03/segment-tree-trick/image-20230821145204412-1706948779867-1.png" alt="Bshu"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护二进制下各位区间内1的数量，因为当对于一个区间都异或x时，若x对应位为1，则区间内1的数量不变；若对应位为0，则区间内1的数量为区间长度-区间内1的数量（即取反），区间和即为各位1的数量并转为十进制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void settag(int id,tag t){</span><br><span class="line">	node[id].t=node[id].t+t;</span><br><span class="line">	for(int i=0;i&lt;=20;++i){</span><br><span class="line">        int tt=(t.opt)&gt;&gt;i&amp;1;</span><br><span class="line">        node[id].val.cnt[i]=(tt?node[id].sz-node[id].val.cnt[i]:node[id].val.cnt[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="New-Year-Tree"><a href="#New-Year-Tree" class="headerlink" title="New Year Tree"></a>New Year Tree</h2><p><a href="https://www.luogu.com.cn/problem/CF620E">https://www.luogu.com.cn/problem/CF620E</a><br><img src="/2024/02/03/segment-tree-trick/image-20230821145746007-1706948779868-2.png" alt="Bshu"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>注意到颜色只有60种，可以通过bitset来存储颜色，树剖实现整体框架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void settag(int id,int t){</span><br><span class="line">    node[id].tag=t;</span><br><span class="line">    node[id].val.bt.reset();</span><br><span class="line">    node[id].val.bt.set(t);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="The-Child-and-Sequence"><a href="#The-Child-and-Sequence" class="headerlink" title="The Child and Sequence"></a>The Child and Sequence</h2><p><a href="https://www.luogu.com.cn/problem/CF438D">https://www.luogu.com.cn/problem/CF438D</a></p>
<p>区间取模</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>暴力修改到结点，同时维护区间最大值，若最大值小于模数则停止递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(node[id].val.maxn&lt;d)return;</span><br></pre></td></tr></table></figure>
<h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>区间求开方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(node[id].val.sum==node[id].sz)return;</span><br></pre></td></tr></table></figure>
<h2 id="TorCoder"><a href="#TorCoder" class="headerlink" title="TorCoder"></a>TorCoder</h2><p><a href="https://www.luogu.com.cn/problem/CF240F">https://www.luogu.com.cn/problem/CF240F</a></p>
<p>给定一个长为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>的由a到z组成的字符串,有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>次操作，每次操作将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.959ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1749.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1020.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1471.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>这些位置的字符进行重排，得到字典序最小的回文字符串，如果无法操作就不进行。<br>求<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>次操作后的字符串。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>维护区间各字母的数量，暴力安排每一步操作<br>容易卡常QAQ</p>
<h2 id="Nastya-and-King-Shamans"><a href="#Nastya-and-King-Shamans" class="headerlink" title="Nastya and King-Shamans"></a>Nastya and King-Shamans</h2><p><a href="https://www.luogu.com.cn/problem/CF992E">https://www.luogu.com.cn/problem/CF992E</a></p>
<p>给定一个序列 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.937ex" height="1.355ex" role="img" focusable="false" viewbox="0 -441 856 598.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>，记其前缀和序列为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.801ex" height="1.357ex" role="img" focusable="false" viewbox="0 -442 796 599.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(502,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>，有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.041ex" height="1.439ex" role="img" focusable="false" viewbox="0 -442 460 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45E" d="M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container> 个询问，每次单点修改，询问是否存在一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 满足 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="8.799ex" height="1.79ex" role="img" focusable="false" viewbox="0 -583 3889.1 791"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(1133.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(2189.5,0)"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="TeXAtom" transform="translate(502,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container> ，有多解输出任意一个，无解输出 −1 。</p>
<p><img src="/2024/02/03/segment-tree-trick/image-20230821151802225-1706948779868-3.png" alt="Bshu"></p>
<h2 id="One-Occurrence"><a href="#One-Occurrence" class="headerlink" title="One Occurrence"></a>One Occurrence</h2><p><a href="https://www.luogu.com.cn/problem/CF1000F">https://www.luogu.com.cn/problem/CF1000F</a></p>
<p>给定一个长度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>序列,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个询问，每次询问给定一个区间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.959ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1749.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1020.7,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1471.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出0，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="15.645ex" height="2.394ex" role="img" focusable="false" viewbox="0 -864 6915.2 1058"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1044.7,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2200.4,0)"><g data-mml-node="text"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g></g><g data-mml-node="mn" transform="translate(4034.2,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><g data-mml-node="mo" transform="translate(4756.4,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="msup" transform="translate(5478.7,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g></g></g></svg></mjx-container> </p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>从左往右扫，val存储对应位置之前出现的位置中最靠前的值以及对应的数。</p>
<h2 id="Boring-Queries"><a href="#Boring-Queries" class="headerlink" title="Boring Queries"></a>Boring Queries</h2><p><a href="https://www.luogu.com.cn/problem/CF1422F">https://www.luogu.com.cn/problem/CF1422F</a></p>
<p>在线求给定区间的lcm</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>对于区间右端点固定，当左端点向左移动时，每次会增加一个数。当且仅当增加的数存在一个因子<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="2.471ex" height="1.969ex" role="img" focusable="false" viewbox="0 -676.2 1092.3 870.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(536,363) scale(0.707)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g></g></g></g></svg></mjx-container> ，原来的lcm的p的指数小于w时，答案会增大。更具体一点，原来lcm的p的指数会对w取max。</p>
<p>这样对于两个数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="11.476ex" height="2.363ex" role="img" focusable="false" viewbox="0 -750 5072.5 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(856,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1300.6,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g><g data-mml-node="mo" transform="translate(2203.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2592.9,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3215.7,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mi" transform="translate(4271.5,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(4683.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，质因子p对应的指数分别为x,y，若x&lt;y，则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.937ex" height="1.355ex" role="img" focusable="false" viewbox="0 -441 856 598.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>一定不会更新答案。这样的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.937ex" height="1.355ex" role="img" focusable="false" viewbox="0 -441 856 598.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>可以直接丢掉。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">// #define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">#define endl '\n'</span><br><span class="line">typedef pair&lt;int,int&gt;pp;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int P = 1e9+7;</span><br><span class="line">LL n,q,idx;</span><br><span class="line">const int N=1e5+10,M=2e5+10;</span><br><span class="line">int a[N],root[N];</span><br><span class="line">struct info{</span><br><span class="line">    LL sum;</span><br><span class="line">};</span><br><span class="line">struct Node{</span><br><span class="line">    int l,r;</span><br><span class="line">    info val;</span><br><span class="line">}node[N*200];</span><br><span class="line">info operator+(const info &amp;a,const info &amp;b){</span><br><span class="line">    return {a.sum*b.sum%P};</span><br><span class="line">}</span><br><span class="line">int build(int l,int r){</span><br><span class="line">    int p=++idx;</span><br><span class="line">    node[p].val.sum=1;</span><br><span class="line">    if(l==r)return r;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    node[p].l=build(l,mid);</span><br><span class="line">    node[p].r=build(mid+1,r);</span><br><span class="line">    return p;</span><br><span class="line">}</span><br><span class="line">void update(int p){</span><br><span class="line">    node[p].val=node[node[p].l].val+node[node[p].r].val;</span><br><span class="line">}</span><br><span class="line">int insert(int p,int l,int r,int x,int d){</span><br><span class="line">    int q=++idx;</span><br><span class="line">    node[q]=node[p];</span><br><span class="line">    if(l==r){</span><br><span class="line">        node[q].val.sum=(node[q].val.sum*d)%P;</span><br><span class="line">        return q;</span><br><span class="line">    }</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(x&lt;=mid)node[q].l=insert(node[q].l,l,mid,x,d);</span><br><span class="line">    else node[q].r=insert(node[q].r,mid+1,r,x,d);</span><br><span class="line">    update(q);</span><br><span class="line">    return q;</span><br><span class="line">}</span><br><span class="line">info query(int p,int l,int r,int ql,int qr){</span><br><span class="line">    if(l==ql&amp;&amp;r==qr)return node[p].val;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(qr&lt;=mid)return query(node[p].l,l,mid,ql,qr);</span><br><span class="line">    else if(ql&gt;mid)return query(node[p].r,mid+1,r,ql,qr);</span><br><span class="line">    else return query(node[p].l,l,mid,ql,mid)+query(node[p].r,mid+1,r,mid+1,qr);    </span><br><span class="line">}</span><br><span class="line">int b[M],pre[M];</span><br><span class="line">LL qmi(LL a,LL b){</span><br><span class="line">    LL res=1;</span><br><span class="line">    a%=P;</span><br><span class="line">    while(b){</span><br><span class="line">        if(b&amp;1)res=res*a%P;</span><br><span class="line">        a=a*a%P;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    }</span><br><span class="line">    return res;</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=2;i&lt;=200000;++i){</span><br><span class="line">        if(!b[i]){</span><br><span class="line">            for(int j=1;i*j&lt;=200000;++j){</span><br><span class="line">                b[i*j]=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">    root[0]=build(1,n);</span><br><span class="line">    vector&lt;pp&gt;vec;</span><br><span class="line">    for(int i=1;i&lt;=n;++i){</span><br><span class="line">        vec.clear();</span><br><span class="line">        int x=a[i];</span><br><span class="line">        root[i]=root[i-1];</span><br><span class="line">        while(b[x]){</span><br><span class="line">            int d=b[x],cnt=0,k=1;</span><br><span class="line">            int inv=qmi(d,P-2);</span><br><span class="line">            while(x%d==0){</span><br><span class="line">                x/=d;</span><br><span class="line">                ++cnt;</span><br><span class="line">                k*=d;</span><br><span class="line">                if(pre[k])vec.push_back({pre[k],inv});</span><br><span class="line">                pre[k]=i;</span><br><span class="line">            }</span><br><span class="line">            pre[k]=i;</span><br><span class="line">            root[i]=insert(root[i],1,n,i,k);</span><br><span class="line">        }</span><br><span class="line">        if(x){</span><br><span class="line">            if(pre[x])vec.push_back({pre[x],qmi(x,P-2)});</span><br><span class="line">            pre[x]=i;</span><br><span class="line">            root[i]=insert(root[i],1,n,i,x);</span><br><span class="line">        }</span><br><span class="line">        LL res=0;</span><br><span class="line">        for(int j=0;j&lt;vec.size();++j){</span><br><span class="line">            if(!j||vec[j].first!=vec[j-1].first)res=1;</span><br><span class="line">            res=res %P *vec[j].second % P;</span><br><span class="line">            if(j+1==vec.size()||vec[j].first!=vec[j+1].first)root[i]=insert(root[i],1,n,vec[j].first,res);</span><br><span class="line">            //cerr&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;vec[j].first&lt;&lt;" "&lt;&lt;vec[j].second&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(q--){</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        //int temp=(int)ans;</span><br><span class="line">        l=(l+ans)%n+1,r=(r+ans)%n+1;</span><br><span class="line">        //cerr&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">        if(l&gt;r)swap(l,r);</span><br><span class="line">        ans=query(root[r],1,n,l,r).sum;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串模板</title>
    <url>/2024/02/04/string/</url>
    <content><![CDATA[<p> 以下是我的字符串模板：编辑距离、后缀数组、回文树、扩展KMP、字符串哈希、AC自动机、Border、KMP、Manacher、SAM</p>
 <span id="more"></span>
<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">#define endl '\n'</span><br><span class="line">const int N=2e3+10;</span><br><span class="line">typedef pair&lt;int,int&gt;pp;</span><br><span class="line">int f[N][N];</span><br><span class="line">signed main()</span><br><span class="line">{</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    </span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    int n=s.size(),m=t.size();</span><br><span class="line">    for(int i=0;i&lt;=n;++i)</span><br><span class="line">        f[i][0]=i;</span><br><span class="line">    for(int i=0;i&lt;=m;++i)</span><br><span class="line">        f[0][i]=i;</span><br><span class="line">    for(int i=1;i&lt;=n;++i){</span><br><span class="line">        for(int j=1;j&lt;=m;++j){</span><br><span class="line">            f[i][j]=min(f[i-1][j],f[i][j-1])+1;</span><br><span class="line">            f[i][j]=min(f[i][j],f[i-1][j-1]+(s[i-1]!=t[j-1]));</span><br><span class="line">            //cerr&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;f[i][j]&lt;&lt;endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.luogu.com.cn/problem/P3809*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=2e6+10;</span><br><span class="line">char s[N];</span><br><span class="line">int n,m;//n为后缀个数, m为桶的个数</span><br><span class="line">int idd[N],cnt[N],sa[N],rk[N],oldrk[N],key1[N];</span><br><span class="line">int height[N];</span><br><span class="line">//桶数组rk[i],辅助数组idd[i],计数数组cnt[i]</span><br><span class="line">bool cmp(int x, int y, int w) {</span><br><span class="line">  return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">}</span><br><span class="line">void get_sa(){</span><br><span class="line">    int i,p,w;</span><br><span class="line">    for (i = 1; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];</span><br><span class="line">    for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];</span><br><span class="line">    for (i = n; i &gt;= 1; --i) sa[cnt[rk[i]]--] = i;</span><br><span class="line"></span><br><span class="line">    for (w = 1;; w &lt;&lt;= 1, m = p) {  // m=p 就是优化计数排序值域</span><br><span class="line">        for (p = 0, i = n; i &gt; n - w; --i) idd[++p] = i;</span><br><span class="line">        for (i = 1; i &lt;= n; ++i)</span><br><span class="line">        if (sa[i] &gt; w) idd[++p] = sa[i] - w;</span><br><span class="line"></span><br><span class="line">        memset(cnt, 0, sizeof(cnt));</span><br><span class="line">        for (i = 1; i &lt;= n; ++i) ++cnt[key1[i] = rk[idd[i]]];</span><br><span class="line">        // 注意这里px[i] != i，因为rk没有更新，是上一轮的排名数组</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];</span><br><span class="line">        for (i = n; i &gt;= 1; --i) sa[cnt[key1[i]]--] = idd[i];</span><br><span class="line">        memcpy(oldrk + 1, rk + 1, n * sizeof(int));</span><br><span class="line">        for (p = 0, i = 1; i &lt;= n; ++i)</span><br><span class="line">            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;</span><br><span class="line">        if (p == n) {</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}  </span><br><span class="line">void get_height(){</span><br><span class="line">    int i,j,k;</span><br><span class="line">    for(i=1;i&lt;=n;i++)rk[sa[i]]=i;</span><br><span class="line">    for(i=1,k=0;i&lt;=n;i++){ //枚举后缀i</span><br><span class="line">        if(rk[i]==1)continue;//第一名height为0</span><br><span class="line">        if(k)k--;//上一个后缀的height值减1</span><br><span class="line">        int j=sa[rk[i]-1];//找出后缀i的前邻后缀j</span><br><span class="line">        while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])k++;</span><br><span class="line">        height[rk[i]]=k;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int main(){</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0),cout.tie(0);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;s+1;</span><br><span class="line">    n=strlen(s+1); m=127;</span><br><span class="line">    get_sa();</span><br><span class="line">    //get_height();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)cout&lt;&lt;sa[i]&lt;&lt;" "&lt;&lt;rk[i]&lt;&lt;" \n";</span><br><span class="line">    //for(int i=1;i&lt;=n;i++)cout&lt;&lt;height[i]&lt;&lt;" \n"[i==n];</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.luogu.com.cn/problem/P5496*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">#define endl '\n'</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">typedef pair&lt;int,int&gt;pp;</span><br><span class="line">int a[N];</span><br><span class="line">struct PAM  {</span><br><span class="line">    static constexpr int M = 26;</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;array&lt;int, M&gt;&gt; t;</span><br><span class="line">    vector&lt;int&gt; link, len, s, trans, val, count;</span><br><span class="line">    int cur, cnt;</span><br><span class="line"></span><br><span class="line">    PAM(){}</span><br><span class="line">    PAM(int x) {init(x);}</span><br><span class="line"></span><br><span class="line">    void init(int x) {</span><br><span class="line">        n = x + 2;</span><br><span class="line">        t.assign(n, {});</span><br><span class="line">        link.assign(n, 0);//fail指针</span><br><span class="line">        count.assign(n, 0);</span><br><span class="line">        val.assign(n, 0);//回文串个数</span><br><span class="line">        len.assign(n, 0);</span><br><span class="line">        s.assign(n, -1);</span><br><span class="line">        trans.assign(n, 0);</span><br><span class="line">        cur = 0;</span><br><span class="line">        cnt = 2;</span><br><span class="line">        len[1] = -1;</span><br><span class="line">        link[0] = link[1] = 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int extend(int p, int c) {</span><br><span class="line">        s[++cur] = c;</span><br><span class="line">        int now = getfail(p);</span><br><span class="line">        if (!t[now][c]) {</span><br><span class="line">            int u = cnt++;</span><br><span class="line">            len[u] = len[now] + 2;</span><br><span class="line">            link[u] = t[getfail(link[now])][c];</span><br><span class="line">            /*if (len[u] &lt; 2)  {</span><br><span class="line">                trans[u] = link[u]; </span><br><span class="line">            } else {</span><br><span class="line">                int tmp = trans[now];</span><br><span class="line">                while (s[cur - len[tmp] - 1] != s[cur] || ((len[tmp] + 2) &lt;&lt; 1) &gt; len[u]) tmp = link[tmp];</span><br><span class="line">                //len[tmp]+2</span><br><span class="line">                trans[u] = t[tmp][c];</span><br><span class="line">                 val[u] = val[link[u]] + 1;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            count[u] = 2 * len[trans[u]] == len[u];</span><br><span class="line">            count[u] += count[link[u]];*/</span><br><span class="line">            val[u] = val[link[u]] + 1;</span><br><span class="line">            t[now][c] = u;</span><br><span class="line">        }</span><br><span class="line">        p = t[now][c];</span><br><span class="line">        //val[p]++;</span><br><span class="line">        return p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int getfail(int x) {</span><br><span class="line">        while (s[cur - len[x] - 1] != s[cur]) x = link[x];</span><br><span class="line">        return x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">} pam;</span><br><span class="line">void solve()</span><br><span class="line">{</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int n=str.size();</span><br><span class="line">    pam.init(n);</span><br><span class="line">    int k=0;</span><br><span class="line">    int p=1;</span><br><span class="line">    for(int i=0;i&lt;n;++i){</span><br><span class="line">        char ch=(str[i]-97+k)%26+97;</span><br><span class="line">        p=pam.extend(p,ch-'a');</span><br><span class="line">        k=pam.val[p];</span><br><span class="line">        cout&lt;&lt;k&lt;&lt;" ";</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">signed main()</span><br><span class="line">{</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int T=1;</span><br><span class="line">    //cin&gt;&gt;T;</span><br><span class="line">    while(T--)	solve();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.luogu.com.cn/problem/P5410*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=2e7+5;</span><br><span class="line">string t,s;</span><br><span class="line">int z[N],p[N];</span><br><span class="line"></span><br><span class="line">void get_z(string s,int n){</span><br><span class="line">    z[1]=n;</span><br><span class="line">    for(int i=2,l,r=0;i&lt;=n;i++){</span><br><span class="line">        if(i&lt;=r)z[i]=min(z[i-l+1],r-i+1);</span><br><span class="line">        while(s[1+z[i]]==s[i+z[i]])z[i]++;</span><br><span class="line">        if(i+z[i]-1&gt;r)l=i,r=i+z[i]-1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">void get_p(string s,int n,string t,int m){</span><br><span class="line">    for(int i=1,l,r=0;i&lt;=m;i++){</span><br><span class="line">        if(i&lt;=r)p[i]=min(z[i-l+1],r-i+1);</span><br><span class="line">        while(1+p[i]&lt;=n&amp;&amp;i+p[i]&lt;=m&amp;&amp;s[1+p[i]]==t[i+p[i]])p[i]++;</span><br><span class="line">        if(i+p[i]-1&gt;r)l=i,r=i+p[i]-1;  </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">std::vector&lt;int&gt; zFunction(std::string s) {//0-base jiangly</span><br><span class="line">    int n = s.size();</span><br><span class="line">    std::vector&lt;int&gt; z(n + 1);</span><br><span class="line">    z[0] = n;</span><br><span class="line">    for (int i = 1, j = 1; i &lt; n; i++) {</span><br><span class="line">        z[i] = std::max(0, std::min(j + z[j] - i, z[i - j]));</span><br><span class="line">        while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) {</span><br><span class="line">            z[i]++;</span><br><span class="line">        }</span><br><span class="line">        if (i + z[i] &gt; j + z[j]) {</span><br><span class="line">            j = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return z;</span><br><span class="line">}</span><br><span class="line">int main(){</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;t&gt;&gt;s;</span><br><span class="line">    t=' '+t,s=' '+s;</span><br><span class="line">    int m=t.size()-1,n=s.size()-1;</span><br><span class="line">    get_z(s,n);</span><br><span class="line">    get_p(s,n,t,m);</span><br><span class="line"></span><br><span class="line">    long long ans1=0,ans2=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        ans1^=1LL*i*(z[i]+1);</span><br><span class="line">    for(int i=1; i&lt;=m; i++)</span><br><span class="line">        ans2^=1LL*i*(p[i]+1);</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;endl&lt;&lt;ans2;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.acwing.com/problem/content/843/*/</span><br><span class="line">/*https://www.acwing.com/problem/content/843/*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define endl '\n' </span><br><span class="line">using namespace std;</span><br><span class="line">const int p=131,N=1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">char str[N];</span><br><span class="line">int pp[N],h[N];</span><br><span class="line">void init()</span><br><span class="line">{</span><br><span class="line">    for(int i=1;i&lt;=n;++i){</span><br><span class="line">        pp[i]=pp[i-1]*p;</span><br><span class="line">        h[i]=h[i-1]*p+str[i];</span><br><span class="line">        //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;h[i]&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">int query(int l,int r){</span><br><span class="line">	//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt; " "&lt;&lt;h[l-1]*pp[r-l+1]&lt;&lt;" "&lt;&lt;h[r]-h[l-1]*pp[r-l+1]&lt;&lt;endl;</span><br><span class="line">    return h[r]-h[l-1]*pp[r-l+1];</span><br><span class="line">}</span><br><span class="line">signed main()</span><br><span class="line">{</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	cin.tie(0);</span><br><span class="line">	cout.tie(0);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;str+1;</span><br><span class="line">    pp[0]=1;</span><br><span class="line">    init();</span><br><span class="line">    for(int i=1;i&lt;=m;++i){</span><br><span class="line">        int l1,r1,l2,r2;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        if(query(l1,r1)==query(l2,r2))cout&lt;&lt;"Yes"&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;"No"&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.luogu.com.cn/problem/P5357*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef char chr;</span><br><span class="line">typedef deque&lt;int&gt; dic;</span><br><span class="line">const int maxN = 2e5;</span><br><span class="line">const int maxS = 2e5;</span><br><span class="line">const int maxT = 2e6;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">chr s[maxS + 10];</span><br><span class="line">chr t[maxT + 10];</span><br><span class="line">int cnt[maxN + 10];</span><br><span class="line"></span><br><span class="line">struct AhoCorasickAutomaton {</span><br><span class="line">    struct Node {</span><br><span class="line">        int son[30];</span><br><span class="line">        int val;</span><br><span class="line">        int fail;</span><br><span class="line">        int head;</span><br><span class="line">        dic index;</span><br><span class="line">    } node[maxS + 10];</span><br><span class="line"></span><br><span class="line">    struct Edge {</span><br><span class="line">        int head;</span><br><span class="line">        int next;</span><br><span class="line">    } edge[maxS + 10];</span><br><span class="line"></span><br><span class="line">    int root;</span><br><span class="line">    int ncnt;</span><br><span class="line">    int ecnt;</span><br><span class="line"></span><br><span class="line">    void Insert(chr *str, int i) {</span><br><span class="line">        int u = root;</span><br><span class="line">        int m=strlen(str+1);</span><br><span class="line">        for (int i = 1; i&lt;=m; i++) {</span><br><span class="line">        if (node[u].son[str[i] - 'a' + 1] == 0)</span><br><span class="line">            node[u].son[str[i] - 'a' + 1] = ++ncnt;</span><br><span class="line">        u = node[u].son[str[i] - 'a' + 1];</span><br><span class="line">        }</span><br><span class="line">        node[u].index.push_back(i);</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Build() {</span><br><span class="line">        dic q;</span><br><span class="line">        for (int i = 1; i &lt;= 26; i++)</span><br><span class="line">        if (node[root].son[i]) q.push_back(node[root].son[i]);</span><br><span class="line">        while (!q.empty()) {</span><br><span class="line">        int u = q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line">        for (int i = 1; i &lt;= 26; i++) {</span><br><span class="line">            if (node[u].son[i]) {</span><br><span class="line">                node[node[u].son[i]].fail = node[node[u].fail].son[i];</span><br><span class="line">                q.push_back(node[u].son[i]);</span><br><span class="line">            } else {</span><br><span class="line">                node[u].son[i] = node[node[u].fail].son[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        }</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Query(chr *str) {</span><br><span class="line">        int u = root;</span><br><span class="line">        int m=strlen(str+1);</span><br><span class="line">        for (int i = 1; i&lt;=m; i++) {</span><br><span class="line">            u = node[u].son[str[i] - 'a' + 1];</span><br><span class="line">            node[u].val++;</span><br><span class="line">        }</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void addEdge(int tail, int head) {</span><br><span class="line">        ecnt++;</span><br><span class="line">        edge[ecnt].head = head;</span><br><span class="line">        edge[ecnt].next = node[tail].head;</span><br><span class="line">        node[tail].head = ecnt;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void DFS(int u) {</span><br><span class="line">        for (int e = node[u].head; e; e = edge[e].next) {</span><br><span class="line">            int v = edge[e].head;</span><br><span class="line">            DFS(v);</span><br><span class="line">            node[u].val += node[v].val;</span><br><span class="line">        }</span><br><span class="line">        for (auto i : node[u].index) cnt[i] += node[u].val;</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void FailTree() {</span><br><span class="line">        for (int u = 1; u &lt;= ncnt; u++) addEdge(node[u].fail, u);</span><br><span class="line">        DFS(root);</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">} ACM;</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) {</span><br><span class="line">        cin &gt;&gt; (s + 1);</span><br><span class="line">        ACM.Insert(s, i);</span><br><span class="line">    }</span><br><span class="line">    ACM.Build();</span><br><span class="line">    cin &gt;&gt; (t + 1);</span><br><span class="line">    ACM.Query(t);</span><br><span class="line">    ACM.FailTree();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)cout &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line">/*</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 8000001</span><br><span class="line">using namespace std;</span><br><span class="line">char s[maxn];</span><br><span class="line">int n, cnt, vis[maxn], rev[maxn], indeg[maxn], ans;</span><br><span class="line"></span><br><span class="line">struct trie_node {</span><br><span class="line">    int son[27];</span><br><span class="line">    int fail;</span><br><span class="line">    int flag;</span><br><span class="line">    int ans;</span><br><span class="line"></span><br><span class="line">    void init() {</span><br><span class="line">        memset(son, 0, sizeof(son));</span><br><span class="line">        fail = flag = 0;</span><br><span class="line">    }</span><br><span class="line">} trie[maxn];</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">void init() {</span><br><span class="line">    for (int i = 0; i &lt;= cnt; i++) trie[i].init();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) vis[i] = 0;</span><br><span class="line">    cnt = 1;</span><br><span class="line">    ans = 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void insert(char *s, int num) {</span><br><span class="line">    int u = 1, len = strlen(s);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) {</span><br><span class="line">        int v = s[i] - 'a';</span><br><span class="line">        if (!trie[u].son[v]) trie[u].son[v] = ++cnt;</span><br><span class="line">        u = trie[u].son[v];</span><br><span class="line">    }</span><br><span class="line">    if (!trie[u].flag) trie[u].flag = num;</span><br><span class="line">    rev[num] = trie[u].flag;</span><br><span class="line">    return;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void getfail(void) {</span><br><span class="line">    for (int i = 0; i &lt; 26; i++) trie[0].son[i] = 1;</span><br><span class="line">    q.push(1);</span><br><span class="line">    trie[1].fail = 0;</span><br><span class="line">    while (!q.empty()) {</span><br><span class="line">        int u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int Fail = trie[u].fail;</span><br><span class="line">        for (int i = 0; i &lt; 26; i++) {</span><br><span class="line">        int v = trie[u].son[i];</span><br><span class="line">        if (!v) {</span><br><span class="line">            trie[u].son[i] = trie[Fail].son[i];</span><br><span class="line">            continue;</span><br><span class="line">        }</span><br><span class="line">        trie[v].fail = trie[Fail].son[i];</span><br><span class="line">        indeg[trie[Fail].son[i]]++;</span><br><span class="line">        q.push(v);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void topu() {</span><br><span class="line">    for (int i = 1; i &lt;= cnt; i++)</span><br><span class="line">        if (!indeg[i]) q.push(i);</span><br><span class="line">        while (!q.empty()) {</span><br><span class="line">        int fr = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[trie[fr].flag] = trie[fr].ans;</span><br><span class="line">        int u = trie[fr].fail;</span><br><span class="line">        trie[u].ans += trie[fr].ans;</span><br><span class="line">        if (!(--indeg[u])) q.push(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void query(char *s) {</span><br><span class="line">    int u = 1, len = strlen(s);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) u = trie[u].son[s[i] - 'a'], trie[u].ans++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    scanf("%d", &amp;n);</span><br><span class="line">    init();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) scanf("%s", s), insert(s, i);</span><br><span class="line">    getfail();</span><br><span class="line">    scanf("%s", s);</span><br><span class="line">    query(s);</span><br><span class="line">    topu();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; vis[rev[i]] &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">}*/</span><br></pre></td></tr></table></figure>
<h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p><strong>引理1</strong>：如果有一个border <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 长度大于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container> 的一半，可以得出得 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container> 有周期 |<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container>|−|<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>|<br><strong>引理2</strong>：如果 p,q都为周期，则 gcd(p,q)也为周期<br><strong>引理3</strong>：字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container>所有不小于 |<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container>|一半的border构成一个等差数列<br><strong>引理4</strong>：可以把字符串分成 log|<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container>|段，每一段的border都是一个等差数列</p>
<p>在KMP匹配中，我们可以利用这个性质快速跳过一串border<br>具体而言，在一次跳border时，如果发现border长度不小于原串的一半，则接下来的border构成等差数列，直到一半以下（引理3）<br>可以直接跳到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.758ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7406.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1183.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(2183.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2572.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3144.4,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(3644.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4144.4,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(4644.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(5164.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5775.7,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="mi" transform="translate(6497.9,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(7017.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 处，即比一半大的第一个位置（整除）（网上博客直接跳到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.297ex" height="1.882ex" role="img" focusable="false" viewbox="0 -750 3667.4 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mi" transform="translate(572,0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/></g><g data-mml-node="mi" transform="translate(1405,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(2147.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3147.4,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container> 处，经过几道题检验也是对的，但不是很能理解）</p>
<p>一次至少跳一半，保证 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="2.851ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 1260 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g></g></g></svg></mjx-container>次以内可以跳完</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.acwing.com/problem/content/description/833/*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define endl '\n' </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class KMP</span><br><span class="line">{</span><br><span class="line">	vector&lt;int&gt; nx;</span><br><span class="line">	string b;</span><br><span class="line">public:</span><br><span class="line">	KMP(string b)</span><br><span class="line">	{</span><br><span class="line">		this-&gt;b = b;</span><br><span class="line">		int n = b.length();</span><br><span class="line">		int j = 0;</span><br><span class="line">		nx.resize(n);</span><br><span class="line">		for (int i = 1; i &lt; n; i++)</span><br><span class="line">		{</span><br><span class="line"></span><br><span class="line">			while (j &gt; 0 &amp;&amp; b[i] != b[j])</span><br><span class="line">				j = nx[j - 1];</span><br><span class="line">			if (b[i] == b[j])</span><br><span class="line">				j++;</span><br><span class="line">			nx[i] = j;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	int find(string a) // a中出现多少次b</span><br><span class="line">	{</span><br><span class="line">		int n = b.length(), m = a.length();</span><br><span class="line">		int j = 0;</span><br><span class="line">		int ans = 0;</span><br><span class="line">		for (int i = 0; i &lt; m; i++)</span><br><span class="line">		{</span><br><span class="line">			while (j &gt; 0 &amp;&amp; a[i] != b[j])</span><br><span class="line">				j = nx[j - 1];</span><br><span class="line">			if (a[i] == b[j])</span><br><span class="line">				j++;</span><br><span class="line">			if (j == n)</span><br><span class="line">			{</span><br><span class="line">				ans++;</span><br><span class="line">				j = nx[j - 1];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		return ans;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line">int m,n;</span><br><span class="line">const int N=1e5+10,M=1e6+10;</span><br><span class="line">int nex[N];</span><br><span class="line">char p[N],s[M];</span><br><span class="line">signed main()</span><br><span class="line">{</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	cin.tie(0);</span><br><span class="line">	cout.tie(0);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;//若无输入字符串长度先提前存储长度，否则Strlen函数将花费大量时间</span><br><span class="line">	</span><br><span class="line">	for(int i=2,j=0;i&lt;=n;++i){</span><br><span class="line">		while(j&amp;&amp;p[j+1]!=p[i])j=nex[j];</span><br><span class="line">		if(p[j+1]==p[i])++j;</span><br><span class="line">		nex[i]=j;</span><br><span class="line">	}</span><br><span class="line">	for(int i=1,j=0;i&lt;=m;++i){</span><br><span class="line">		while(j&amp;&amp;p[j+1]!=s[i])j=nex[j];</span><br><span class="line">		if(p[j+1]==s[i])++j;</span><br><span class="line">		if(j==n){</span><br><span class="line">            //匹配成功</span><br><span class="line">			cout&lt;&lt;i-n&lt;&lt;" ";</span><br><span class="line">			j=nex[j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br><span class="line">/*3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa*/</span><br></pre></td></tr></table></figure>
<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.luogu.com.cn/problem/P3805*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define endl '\n'</span><br><span class="line">const int N=11e6+10;</span><br><span class="line">string str,ss;</span><br><span class="line">int d[N*2],ans=1;//ans包括#</span><br><span class="line">inline void getd(string s){</span><br><span class="line">    d[1]=1;</span><br><span class="line">    for(int i=2,l,r=1;i&lt;s.size();++i){</span><br><span class="line">        if(i&lt;=r)d[i]=min(d[r-i+l],r-i+1);</span><br><span class="line">        while(s[i-d[i]]==s[i+d[i]])d[i]++;</span><br><span class="line">        if(i+d[i]-1&gt;r)l=i-d[i]+1,r=i+d[i]-1;</span><br><span class="line">        ans=max(ans,d[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    ss+='$';</span><br><span class="line">    ss+='#';</span><br><span class="line">    for(int i=0;i&lt;str.size();++i){</span><br><span class="line">        ss+=str[i];</span><br><span class="line">        ss+='#';</span><br><span class="line">    }</span><br><span class="line">    getd(ss);</span><br><span class="line">    cout&lt;&lt;ans-1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*https://www.luogu.com.cn/problem/P3804*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">// #define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">#define endl '\n'</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int NN=2e6+10;</span><br><span class="line">typedef pair&lt;int,int&gt;pp;</span><br><span class="line">struct SAM {</span><br><span class="line">    static const int M = 26, N = 1e6;</span><br><span class="line">    struct Node {</span><br><span class="line">        int len;</span><br><span class="line">        int link;</span><br><span class="line">        int sz;</span><br><span class="line">        array&lt;int, M&gt; nxt;</span><br><span class="line">        Node() = default;</span><br><span class="line">    } t[2 * N];</span><br><span class="line">    int cnt;</span><br><span class="line">    SAM() {init();}</span><br><span class="line">    int newNode() {</span><br><span class="line">        int u = cnt++;</span><br><span class="line">        t[u].len = t[u].link = 0;</span><br><span class="line">        t[u].nxt.fill(0);</span><br><span class="line">        t[u].sz=0;</span><br><span class="line">        // t[u].sz=1;</span><br><span class="line">        return u;</span><br><span class="line">    }</span><br><span class="line">    void init() {</span><br><span class="line">        cnt = 0;</span><br><span class="line">        newNode();</span><br><span class="line">        newNode();</span><br><span class="line">        t[0].nxt.fill(1);</span><br><span class="line">        t[0].len = -1;</span><br><span class="line">    }</span><br><span class="line">    int extend(int p, int c) {</span><br><span class="line">        // cerr&lt;&lt;p&lt;&lt;" "&lt;&lt;t[p].nxt[c]&lt;&lt;" "&lt;&lt;t[p].len&lt;&lt;" "&lt;&lt;t[p].link&lt;&lt;endl;</span><br><span class="line">        if (t[p].nxt[c]) {</span><br><span class="line">            int q = t[p].nxt[c];</span><br><span class="line">            if (t[q].len == t[p].len + 1)</span><br><span class="line">                return q;</span><br><span class="line">            int r = newNode();</span><br><span class="line">            t[r] = t[q];</span><br><span class="line">            t[r].sz=0;</span><br><span class="line">            t[r].len = t[p].len + 1;</span><br><span class="line">            t[q].link = r;</span><br><span class="line">            while (t[p].nxt[c] == q) {</span><br><span class="line">                t[p].nxt[c] = r;</span><br><span class="line">                p = t[p].link;</span><br><span class="line">            }</span><br><span class="line">            return r;</span><br><span class="line">        }</span><br><span class="line">        int cur = newNode();</span><br><span class="line">        // cerr&lt;&lt;"cur:"&lt;&lt;cur&lt;&lt;" "&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">        t[cur].len = t[p].len + 1;</span><br><span class="line">        t[cur].sz=1;</span><br><span class="line"></span><br><span class="line">        while (!t[p].nxt[c]) {</span><br><span class="line">            t[p].nxt[c] = cur;</span><br><span class="line">            p = t[p].link;</span><br><span class="line">        }</span><br><span class="line">        t[cur].link = extend(p, c);</span><br><span class="line">        // cerr&lt;&lt;"cur"&lt;&lt;cur&lt;&lt;" "&lt;&lt;t[cur].link&lt;&lt;" "&lt;&lt;t[cur].len&lt;&lt;endl;</span><br><span class="line">        return cur;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    int extend(int p, char c, char offset = 'a') {</span><br><span class="line">        return extend(p, c - offset);</span><br><span class="line">    }</span><br><span class="line">    int nxt(int p, int x) {</span><br><span class="line">        return t[p].nxt[x];</span><br><span class="line">    }</span><br><span class="line">    int nxt(int p, char c, char offset = 'a') {</span><br><span class="line">        return nxt(p, c - 'a');</span><br><span class="line">    }</span><br><span class="line">    int link(int p) {</span><br><span class="line">        return t[p].link;</span><br><span class="line">    }</span><br><span class="line">    int len(int p) {</span><br><span class="line">        return t[p].len;</span><br><span class="line">    }</span><br><span class="line">    int size() {</span><br><span class="line">        return cnt;</span><br><span class="line">    }</span><br><span class="line">} sam;</span><br><span class="line">int h[NN],e[NN],nt[NN],idx;</span><br><span class="line">void add(int a,int b){</span><br><span class="line">    e[++idx]=b;</span><br><span class="line">    nt[idx]=h[a];</span><br><span class="line">    h[a]=idx;</span><br><span class="line">}</span><br><span class="line">ll res=0;</span><br><span class="line">void dfs(int u){</span><br><span class="line">    for(int i=h[u];i!=-1;i=nt[i]){</span><br><span class="line">        dfs(e[i]);</span><br><span class="line">        sam.t[u].sz+=sam.t[e[i]].sz;</span><br><span class="line">    }</span><br><span class="line">    if(sam.t[u].sz!=1){</span><br><span class="line">        // cerr&lt;&lt;sam.t[u].sz&lt;&lt;" "&lt;&lt;sam.t[u].len&lt;&lt;endl;</span><br><span class="line">        res=max(res,1ll*sam.t[u].sz*sam.t[u].len);</span><br><span class="line">        // cerr&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">void solve()</span><br><span class="line">{</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int n=str.size();</span><br><span class="line">    vector&lt;int&gt;p(n+1);</span><br><span class="line">    p[0]=1;</span><br><span class="line">    for(int i=0;i&lt;n;++i){</span><br><span class="line">        // cerr&lt;&lt;str[i]&lt;&lt;endl;</span><br><span class="line">        p[i+1]=sam.extend(p[i],str[i]);</span><br><span class="line">        // cerr&lt;&lt;p[i+1]&lt;&lt;" "&lt;&lt;sam.t[p[i+1]].nxt[str[i]]&lt;&lt;" "&lt;&lt;sam.t[p[i+1]].len&lt;&lt;" "&lt;&lt;sam.t[p[i+1]].link&lt;&lt;endl;</span><br><span class="line">        // cerr&lt;&lt;"cnt"&lt;&lt;sam.cnt&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;sam.size();++i){</span><br><span class="line">        add(sam.link(i),i);</span><br><span class="line">    }</span><br><span class="line">    dfs(1);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int T=1;</span><br><span class="line">    // cin&gt;&gt;T;</span><br><span class="line">    while(T--)	solve();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树模板</title>
    <url>/2024/02/02/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="以下是我的线段树模板"><a href="#以下是我的线段树模板" class="headerlink" title="以下是我的线段树模板"></a>以下是我的线段树模板</h1><p>参考了dls的线段树模板，封装<code>+</code>减少了许多的码量</p>
 <span id="more"></span>
<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*http://oj.daimayuan.top/course/15/problem/658*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	<span class="type">int</span> ans,s,ps,bs;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	info val;</span><br><span class="line">&#125;node[N*<span class="number">4</span>];</span><br><span class="line">info <span class="keyword">operator</span> +(<span class="type">const</span> info &amp;a,<span class="type">const</span> info &amp;b)&#123;</span><br><span class="line">	info res;</span><br><span class="line">	res.ans=<span class="built_in">max</span>(&#123;a.ans,b.ans,a.bs+b.ps&#125;);</span><br><span class="line">	res.ps=<span class="built_in">max</span>(a.ps,a.s+b.ps);</span><br><span class="line">	res.bs=<span class="built_in">max</span>(b.bs,a.bs+b.s);</span><br><span class="line">	res.s=a.s+b.s;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	node[id].val=node[id*<span class="number">2</span>].val+node[id*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		node[id]=&#123;a[l],a[l],a[l],a[l]&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(id*<span class="number">2</span>,l,mid);</span><br><span class="line">		<span class="built_in">build</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		node[id].val=&#123;d,d,d,d&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">change</span>(id*<span class="number">2</span>,l,mid,pos,d);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">change</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,d);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==ql&amp;&amp;r==qr)&#123;</span><br><span class="line">		<span class="keyword">return</span> node[id].val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>,l,mid,ql,qr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>,l,mid,ql,mid)+<span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="type">int</span> opt;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> x,d;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;d;</span><br><span class="line">			<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,d);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> l,r;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="keyword">auto</span> res=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">			cout&lt;&lt;res.ans&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*http://oj.daimayuan.top/course/15/problem/660*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tag</span>&#123;</span><br><span class="line">	<span class="type">int</span> mul,add;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	info val;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">	tag t;</span><br><span class="line">&#125;node[N*<span class="number">4</span>];</span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info &amp;a,<span class="type">const</span> info &amp;b)&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;(a.sum+b.sum)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">tag <span class="keyword">operator</span>+(<span class="type">const</span> tag &amp;a,<span class="type">const</span> tag &amp;b)&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;a.mul*b.mul%mod,(a.add*b.mul+b.add)%mod&#125;;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">settag</span><span class="params">(<span class="type">int</span> id,tag t)</span></span>&#123;</span><br><span class="line">	node[id].t=node[id].t+t;</span><br><span class="line">	node[id].val.sum=(node[id].val.sum*t.mul+node[id].sz*t.add)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	node[id].val=node[id*<span class="number">2</span>].val+node[id*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[id].t.mul!=<span class="number">1</span>||node[id].t.add!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">settag</span>(id*<span class="number">2</span>,node[id].t);</span><br><span class="line">		<span class="built_in">settag</span>(id*<span class="number">2</span>+<span class="number">1</span>,node[id].t);</span><br><span class="line">		node[id].t=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	node[id].sz=r-l+<span class="number">1</span>;</span><br><span class="line">	node[id].t=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l==r)node[id].val.sum=a[l];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(id*<span class="number">2</span>,l,mid);</span><br><span class="line">		<span class="built_in">build</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,tag t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==ql&amp;&amp;r==qr)&#123;</span><br><span class="line">		<span class="built_in">settag</span>(id,t);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(id);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(qr&lt;=mid)<span class="built_in">modify</span>(id*<span class="number">2</span>,l,mid,ql,qr,t);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ql&gt;mid)<span class="built_in">modify</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr,t);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">modify</span>(id*<span class="number">2</span>,l,mid,ql,mid,t);</span><br><span class="line">		<span class="built_in">modify</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,qr,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql==l&amp;&amp;qr==r)&#123;</span><br><span class="line">		<span class="keyword">return</span> node[id].val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(id);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(qr&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>,l,mid,ql,qr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ql&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(id*<span class="number">2</span>,l,mid,ql,mid)+<span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,qr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="type">int</span> opt;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> l,r,d;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,tag&#123;<span class="number">1</span>,d&#125;);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="type">int</span> l,r,d;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,tag&#123;d,<span class="number">0</span>&#125;); </span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="type">int</span> l,r,d;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,tag&#123;<span class="number">0</span>,d&#125;);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> l,r;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="keyword">auto</span> res=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">			cout&lt;&lt;res.sum&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="线段树哈希"><a href="#线段树哈希" class="headerlink" title="线段树哈希"></a>线段树哈希</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*https://codeforces.com/problemset/problem/213/E*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> int64;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,D=<span class="number">200003</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pp;</span><br><span class="line"><span class="type">int</span> a[N],b[N],pos[N];</span><br><span class="line">int64 d[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">    int64 num;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	info val;</span><br><span class="line">&#125;node[N*<span class="number">4</span>];</span><br><span class="line">info <span class="keyword">operator</span> +(<span class="type">const</span> info &amp;a,<span class="type">const</span> info &amp;b)&#123;</span><br><span class="line">	info temp;</span><br><span class="line">    temp.res=a.res+b.res;</span><br><span class="line">    temp.num=a.num*d[b.res]+b.num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	node[id].val=node[id*<span class="number">2</span>].val+node[id*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> dd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		node[id].val=&#123;dd?node[id].val.res+<span class="number">1</span>:node[id].val.res<span class="number">-1</span>,(int64)dd&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">change</span>(id*<span class="number">2</span>,l,mid,pos,dd);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">change</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,dd);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int64 sum=<span class="number">0</span>,aa=<span class="number">0</span>;</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum=sum*D+a[i];</span><br><span class="line">        d[i]=d[i<span class="number">-1</span>]*D;</span><br><span class="line">        aa+=d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        pos[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;n)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,m,pos[i-n],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,m,pos[i],i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n&amp;&amp;node[<span class="number">1</span>].val.num==(i-n)*aa+sum)</span><br><span class="line">            ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*https://codeforces.com/problemset/problem/213/E*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> int64;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,D=<span class="number">200003</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pp;</span><br><span class="line"><span class="type">int</span> a[N],b[N],pos[N];</span><br><span class="line">int64 d[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">    int64 num;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	info val;</span><br><span class="line">&#125;node[N*<span class="number">4</span>];</span><br><span class="line">info <span class="keyword">operator</span> +(<span class="type">const</span> info &amp;a,<span class="type">const</span> info &amp;b)&#123;</span><br><span class="line">	info temp;</span><br><span class="line">    temp.res=a.res+b.res;</span><br><span class="line">    temp.num=a.num*d[b.res]+b.num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	node[id].val=node[id*<span class="number">2</span>].val+node[id*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> dd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		node[id].val=&#123;dd?node[id].val.res+<span class="number">1</span>:node[id].val.res<span class="number">-1</span>,(int64)dd&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">change</span>(id*<span class="number">2</span>,l,mid,pos,dd);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">change</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,dd);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int64 sum=<span class="number">0</span>,aa=<span class="number">0</span>;</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum=sum*D+a[i];</span><br><span class="line">        d[i]=d[i<span class="number">-1</span>]*D;</span><br><span class="line">        aa+=d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        pos[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;n)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,m,pos[i-n],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,m,pos[i],i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n&amp;&amp;node[<span class="number">1</span>].val.num==(i-n)*aa+sum)</span><br><span class="line">            ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树建图"><a href="#线段树建图" class="headerlink" title="线段树建图"></a>线段树建图</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*https://codeforces.com/problemset/problem/213/E*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> int64;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,D=<span class="number">200003</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pp;</span><br><span class="line"><span class="type">int</span> a[N],b[N],pos[N];</span><br><span class="line">int64 d[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">    int64 num;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	info val;</span><br><span class="line">&#125;node[N*<span class="number">4</span>];</span><br><span class="line">info <span class="keyword">operator</span> +(<span class="type">const</span> info &amp;a,<span class="type">const</span> info &amp;b)&#123;</span><br><span class="line">	info temp;</span><br><span class="line">    temp.res=a.res+b.res;</span><br><span class="line">    temp.num=a.num*d[b.res]+b.num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	node[id].val=node[id*<span class="number">2</span>].val+node[id*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> dd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		node[id].val=&#123;dd?node[id].val.res+<span class="number">1</span>:node[id].val.res<span class="number">-1</span>,(int64)dd&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">change</span>(id*<span class="number">2</span>,l,mid,pos,dd);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">change</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,dd);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int64 sum=<span class="number">0</span>,aa=<span class="number">0</span>;</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum=sum*D+a[i];</span><br><span class="line">        d[i]=d[i<span class="number">-1</span>]*D;</span><br><span class="line">        aa+=d[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        pos[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;n)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,m,pos[i-n],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,m,pos[i],i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n&amp;&amp;node[<span class="number">1</span>].val.num==(i-n)*aa+sum)</span><br><span class="line">            ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
